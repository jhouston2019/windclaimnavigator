const { PDFDocument } = require('pdf-lib');
const crypto = require('crypto');

/**
 * Applies watermarking to a PDF (password protection will be added via external tool)
 * @param {Buffer} pdfBuffer - The original PDF buffer
 * @param {string} userEmail - User's email for watermark
 * @returns {Promise<Buffer>} - Watermarked PDF buffer
 */
async function protectPDF(pdfBuffer, userEmail) {
  try {
    // Load the PDF document
    const pdfDoc = await PDFDocument.load(pdfBuffer);
    const pages = pdfDoc.getPages();
    
    // Add watermark to each page
    for (let i = 0; i < pages.length; i++) {
      const page = pages[i];
      const { width, height } = page.getSize();
      
      // Add watermark at the bottom center of each page
      page.drawText(`Generated by Claim Navigator for ${userEmail}`, {
        x: width / 2 - 150, // Center horizontally (approximate)
        y: 30, // Bottom margin
        size: 8,
        color: { r: 0.5, g: 0.5, b: 0.5 }, // Light gray
        opacity: 0.6
      });
    }
    
    const watermarkedPdfBytes = await pdfDoc.save();
    
    console.log(`PDF watermarked for user: ${userEmail}`);
    return Buffer.from(watermarkedPdfBytes);
    
  } catch (error) {
    console.error('Error watermarking PDF:', error);
    throw new Error(`Failed to watermark PDF: ${error.message}`);
  }
}

/**
 * Generates a secure PDF with password protection and watermarking
 * @param {string} content - Document content
 * @param {string} userEmail - User's email
 * @param {string} title - Document title
 * @returns {Promise<Buffer>} - Protected PDF buffer
 */
async function generateSecurePDF(content, userEmail, title = 'Claim Navigator Document') {
  const PDFDocument = require('pdfkit');
  
  // Create PDF with PDFKit
  const doc = new PDFDocument({
    size: 'A4',
    margins: {
      top: 50,
      bottom: 80, // Extra space for watermark
      left: 50,
      right: 50
    }
  });

  const chunks = [];
  doc.on('data', chunk => chunks.push(chunk));

  // Add header
  doc.fontSize(16)
     .font('Helvetica-Bold')
     .text(title, { align: 'center' })
     .moveDown();

  // Add timestamp
  doc.fontSize(10)
     .font('Helvetica')
     .text(`Generated on: ${new Date().toLocaleString()}`, { align: 'right' })
     .moveDown();

  // Add main content
  doc.fontSize(12)
     .font('Helvetica')
     .text(content, {
       width: 500,
       align: 'left',
       lineGap: 5
     });

  // Add footer watermark
  doc.fontSize(8)
     .font('Helvetica')
     .fillColor('#B0B0B0') // Light gray
     .text(`Generated by Claim Navigator for ${userEmail}`, { 
       align: 'center',
       opacity: 0.6
     });

  // Finalize the PDF
  doc.end();

  // Wait for PDF to be generated
  await new Promise((resolve, reject) => {
    doc.on('end', resolve);
    doc.on('error', reject);
  });

  const pdfBuffer = Buffer.concat(chunks);
  
  // Apply watermarking using pdf-lib
  const watermarkedBuffer = await protectPDF(pdfBuffer, userEmail);
  
  // Apply password protection
  const ownerPassword = crypto.randomBytes(16).toString('hex');
  const userPassword = userEmail;
  
  const protectedBuffer = await addPasswordProtection(watermarkedBuffer, userPassword, ownerPassword);
  
  return protectedBuffer;
}

/**
 * Creates a password-protected PDF using external qpdf command
 * Note: This requires qpdf to be available in the environment
 * @param {Buffer} pdfBuffer - Original PDF buffer
 * @param {string} userPassword - User password (email)
 * @param {string} ownerPassword - Owner password (random)
 * @returns {Promise<Buffer>} - Password-protected PDF buffer
 */
async function addPasswordProtection(pdfBuffer, userPassword, ownerPassword) {
  const fs = require('fs');
  const path = require('path');
  const { exec } = require('child_process');
  const { promisify } = require('util');
  const execAsync = promisify(exec);
  
  try {
    // Create temporary files
    const tempDir = '/tmp';
    const inputFile = path.join(tempDir, `input_${Date.now()}.pdf`);
    const outputFile = path.join(tempDir, `output_${Date.now()}.pdf`);
    
    // Write input PDF to temporary file
    fs.writeFileSync(inputFile, pdfBuffer);
    
    // Try to use qpdf for password protection
    try {
      const qpdfCommand = `qpdf --encrypt "${userPassword}" "${ownerPassword}" 128 --print=full --modify=none --extract=y --assemble=n --annotate=n --form=n --use-aes=y -- "${inputFile}" "${outputFile}"`;
      
      await execAsync(qpdfCommand);
      
      // Read the protected PDF
      const protectedBuffer = fs.readFileSync(outputFile);
      
      // Clean up temporary files
      fs.unlinkSync(inputFile);
      fs.unlinkSync(outputFile);
      
      console.log(`Password protection applied using qpdf for user: ${userPassword}`);
      return protectedBuffer;
      
    } catch (qpdfError) {
      console.warn('qpdf not available, using fallback method:', qpdfError.message);
      
      // Fallback: Add password protection using pdf-lib with basic encryption
      const { PDFDocument } = require('pdf-lib');
      const pdfDoc = await PDFDocument.load(pdfBuffer);
      
      // Set basic security properties
      pdfDoc.setTitle('Claim Navigator Document');
      pdfDoc.setAuthor('Claim Navigator');
      pdfDoc.setSubject('Insurance Claim Document');
      pdfDoc.setKeywords(['claim', 'insurance', 'document']);
      pdfDoc.setProducer('Claim Navigator');
      pdfDoc.setCreator('Claim Navigator');
      
      // Note: pdf-lib doesn't support password protection directly
      // This is a placeholder for future implementation
      console.log(`Basic security metadata added for user: ${userPassword}`);
      
      const protectedBytes = await pdfDoc.save();
      
      // Clean up temporary files
      if (fs.existsSync(inputFile)) fs.unlinkSync(inputFile);
      if (fs.existsSync(outputFile)) fs.unlinkSync(outputFile);
      
      return Buffer.from(protectedBytes);
    }
    
  } catch (error) {
    console.error('Error adding password protection:', error);
    // Return original buffer if protection fails
    return pdfBuffer;
  }
}

module.exports = {
  protectPDF,
  generateSecurePDF,
  addPasswordProtection
};
