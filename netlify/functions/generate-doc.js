const { PDFDocument, rgb, StandardFonts } = require('pdf-lib');
const ExcelJS = require('exceljs');
const Docx = require('docx');

exports.handler = async (event, context) => {
    // Set CORS headers
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Content-Type': 'application/json'
    };

    // Handle preflight requests
    if (event.httpMethod === 'OPTIONS') {
        return {
            statusCode: 200,
            headers,
            body: ''
        };
    }

    // Only allow POST requests
    if (event.httpMethod !== 'POST') {
        return {
            statusCode: 405,
            headers,
            body: JSON.stringify({ error: 'Method not allowed' })
        };
    }

    try {
        // Parse request body
        const requestData = JSON.parse(event.body);
        const { documentId, documentType, outputType, layoutType, formData } = requestData;

        if (!documentId || !formData) {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Missing required fields' })
            };
        }

        let result;
        
        // Generate document based on output type
        switch (outputType.toLowerCase()) {
            case 'pdf':
                result = await generatePDF(documentId, documentType, layoutType, formData);
                break;
            case 'docx':
                result = await generateDOCX(documentId, documentType, layoutType, formData);
                break;
            case 'xlsx':
                result = await generateXLSX(documentId, documentType, layoutType, formData);
                break;
            default:
                throw new Error(`Unsupported output type: ${outputType}`);
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
                success: true,
                filename: result.filename,
                mimeType: result.mimeType,
                contentBase64: result.contentBase64
            })
        };

    } catch (error) {
        console.error('Error generating document:', error);
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({
                success: false,
                error: error.message
            })
        };
    }
};

// Generate PDF document
async function generatePDF(documentId, documentType, layoutType, formData) {
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([612, 792]); // Letter size
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    
    let yPosition = 750;
    const lineHeight = 20;
    const margin = 50;
    
    // Title
    page.drawText(documentType, {
        x: margin,
        y: yPosition,
        size: 18,
        font: boldFont,
        color: rgb(0, 0, 0)
    });
    yPosition -= 30;
    
    // Date
    page.drawText(`Generated: ${new Date().toLocaleDateString()}`, {
        x: margin,
        y: yPosition,
        size: 12,
        font: font,
        color: rgb(0.5, 0.5, 0.5)
    });
    yPosition -= 40;
    
    // Form data
    for (const [key, value] of Object.entries(formData)) {
        if (value && value.toString().trim()) {
            const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
            const text = `${label}: ${value}`;
            
            // Check if text fits on current line
            const textWidth = font.widthOfTextAtSize(text, 12);
            if (textWidth > 500) {
                yPosition -= lineHeight;
            }
            
            if (yPosition < 100) {
                // Add new page if needed
                const newPage = pdfDoc.addPage([612, 792]);
                yPosition = 750;
            }
            
            page.drawText(text, {
                x: margin,
                y: yPosition,
                size: 12,
                font: font,
                color: rgb(0, 0, 0)
            });
            yPosition -= lineHeight;
        }
    }
    
    // Footer
    yPosition = 50;
    page.drawText('Generated by Claim Navigator', {
        x: margin,
        y: yPosition,
        size: 10,
        font: font,
        color: rgb(0.5, 0.5, 0.5)
    });
    
    const pdfBytes = await pdfDoc.save();
    const base64 = Buffer.from(pdfBytes).toString('base64');
    
    return {
        filename: `${documentId}-${Date.now()}.pdf`,
        mimeType: 'application/pdf',
        contentBase64: base64
    };
}

// Generate DOCX document
async function generateDOCX(documentId, documentType, layoutType, formData) {
    const doc = new Docx.Document({
        sections: [{
            properties: {},
            children: [
                new Docx.Paragraph({
                    children: [
                        new Docx.TextRun({
                            text: documentType,
                            bold: true,
                            size: 32
                        })
                    ],
                    alignment: Docx.AlignmentType.CENTER
                }),
                new Docx.Paragraph({
                    children: [
                        new Docx.TextRun({
                            text: `Generated: ${new Date().toLocaleDateString()}`,
                            size: 20
                        })
                    ],
                    alignment: Docx.AlignmentType.CENTER
                }),
                new Docx.Paragraph({
                    children: [new Docx.TextRun({ text: "" })]
                }),
                ...Object.entries(formData).map(([key, value]) => {
                    if (value && value.toString().trim()) {
                        const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        return new Docx.Paragraph({
                            children: [
                                new Docx.TextRun({
                                    text: `${label}: `,
                                    bold: true
                                }),
                                new Docx.TextRun({
                                    text: value.toString()
                                })
                            ]
                        });
                    }
                    return null;
                }).filter(Boolean),
                new Docx.Paragraph({
                    children: [new Docx.TextRun({ text: "" })]
                }),
                new Docx.Paragraph({
                    children: [
                        new Docx.TextRun({
                            text: "Generated by Claim Navigator",
                            italics: true,
                            size: 20
                        })
                    ],
                    alignment: Docx.AlignmentType.CENTER
                })
            ]
        }]
    });
    
    const buffer = await Docx.Packer.toBuffer(doc);
    const base64 = buffer.toString('base64');
    
    return {
        filename: `${documentId}-${Date.now()}.docx`,
        mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        contentBase64: base64
    };
}

// Generate XLSX document
async function generateXLSX(documentId, documentType, layoutType, formData) {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Document Data');
    
    // Set column headers
    worksheet.columns = [
        { header: 'Field', key: 'field', width: 30 },
        { header: 'Value', key: 'value', width: 50 }
    ];
    
    // Add title row
    worksheet.addRow({ field: 'Document Type', value: documentType });
    worksheet.addRow({ field: 'Generated Date', value: new Date().toLocaleDateString() });
    worksheet.addRow({ field: '', value: '' }); // Empty row
    
    // Add form data
    Object.entries(formData).forEach(([key, value]) => {
        if (value && value.toString().trim()) {
            const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
            worksheet.addRow({ field: label, value: value.toString() });
        }
    });
    
    // Style the worksheet
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(2).font = { bold: true };
    
    const buffer = await workbook.xlsx.writeBuffer();
    const base64 = Buffer.from(buffer).toString('base64');
    
    return {
        filename: `${documentId}-${Date.now()}.xlsx`,
        mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        contentBase64: base64
    };
}